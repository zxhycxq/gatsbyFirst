{"data":{"content":{"edges":[{"node":{"id":"9c369d83-e367-5659-baeb-91b6d76e247c","html":"<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p>異步操作是非常常見的操作，也是其中一題常見的前端工程師面試題目。在日常開發中，我們會和伺服器交互，或者是和用戶的行動作出反應，比如說監聽某些點擊事件。這個時候，其實我們是執行了異步操作，我們需要等待對方若干時間才能收到返回值，甚至是一個錯誤的值。。。因此，異步操作很容易產生一些誤會。這裡，我會說一下異步操作，及其返回的處理方法。</p>\n<h2 id=\"同步與異步的分別\"><a href=\"#%E5%90%8C%E6%AD%A5%E8%88%87%E7%95%B0%E6%AD%A5%E7%9A%84%E5%88%86%E5%88%A5\" aria-label=\"同步與異步的分別 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>同步與異步的分別</h2>\n<p>在同步的世界裡面，我們希望執行某些操作之後，就能夠馬上拿到返回的值，然後執行下一步。然而，當我們發出 HTTP 請求的時候，我們可能需要等待世界的另外一端返回信息，這需要時間，便不是同步了。。。</p>\n<p>如果沒有異步的話，當你發出 HTTP 請求的時候，瀏覽器需要等待伺服器返回才執行下一步。這就是代表瀏覽器會卡住。。。</p>\n<p>異步處理，簡單來說就是我們發出了一個行動，但是不是馬上得到結果，我們會繼續執行後面的指令，等到函數裡面有一個返回，我們才拿那個返回值來使用。最簡單的說法，就是我們向服務器發出請求，但是服務器需要時間處理，並且返回處理過的內容。</p>\n<h2 id=\"異步操作處理方法\"><a href=\"#%E7%95%B0%E6%AD%A5%E6%93%8D%E4%BD%9C%E8%99%95%E7%90%86%E6%96%B9%E6%B3%95\" aria-label=\"異步操作處理方法 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>異步操作處理方法</h2>\n<ol>\n<li>Callback</li>\n<li>Promise （思想）</li>\n<li>Generator</li>\n<li>Async await （推薦）</li>\n</ol>\n<h3 id=\"callback\"><a href=\"#callback\" aria-label=\"callback permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Callback</h3>\n<p>我們看一下維基百科上面對於 Callback 的說明：</p>\n<blockquote>\n<p>在電腦程式設計中，回呼函式，或簡稱回呼（Callback 即 call then back 被主函數呼叫運算後會返回主函數），是指通過函數參數傳遞到其它代碼的，某一塊可執行代碼的參照。這一設計允許了底層代碼呼叫在高層定義的子程式。</p>\n</blockquote>\n<p>這樣好像說得蠻複雜的，但其實很簡單，你把一個函數 cb (Function) 作為參數 (Argument)傳進這個函數 B 裡面，然後在函數 B 使用函數 cb。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function func(x, cb) {\n  cb(x)\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>舉個例子，比如我們要在 Node.js 裡面讀取一個檔案，我們的代碼會是下面這樣的：</p>\n<p>hello.txt:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello World, I&#39;m Calpa Liu.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<hr>\n<p>index.js:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var fs = require(&#39;fs&#39;);\n\nfs.readFile(&#39;hello.txt&#39;, function (err, data) {\n     if (err) {\n          return console.error(err);\n     }\n\n     console.log(data);\n});\n\nconsole.log(&#39;Finished&#39;);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我們會在 callback 裡面處理 callback，也就是一個回調裡面做另外一件事情，那可能是另外一個 callback，那麼你可以想象一下，我們越寫越深。。。這樣有兩個問題，第一：代碼的耦合性會很高，不容易去拆分代碼；第二：代碼的維護性很差。</p>\n<p><img src=\"https://i.imgur.com/bjHDvVN.jpg\" alt=\"Imgur\"></p>\n<h3 id=\"promise\"><a href=\"#promise\" aria-label=\"promise permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise</h3>\n<p>Promise 是說如果你做了 A 的事情，成功了就做 B，不成功就做 C，你還可以繼續做 D 的事情，然後進行成功和不成功的處理。這樣說可能比較虛，但是你看一下 MDN 上面的圖就會明白了。</p>\n<p><img src=\"https://i.imgur.com/w9BxjmL.png\" alt=\"Promise - MDN\"></p>\n<p>一個發射子彈的動作可以這樣寫：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var fire = new Promise(function(resolve, reject) {\n     setTimeout(function() {\n          resolve(&#39;已命中三千里外的目標&#39;);\n     }, 3000)\n});\n\nfire.then(function(result) {\n     console.log(result);\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以在 Windows 平台按 F12 或 Ctrl + Shift + I，或在 Mac 上 按 Cmd + Opt + I，打開 Google Chrome Developer Tools ，然後在 Console 貼上上面的代碼，三秒後就會輸出<code class=\"language-text\">已命中三千里外的目標</code>。</p>\n<p>你也可以在 then() 裡面寫 1 個到 N 個的 Promise。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var fire = new Promise(function(resolve, reject) {\n     setTimeout(function() {\n          resolve(&#39;已命中三千里外的目標&#39;);\n     }, 3000)\n});\n\nfire.then(function(result) {\n     console.log(result);\n     console.log(&#39;正在返回司令部&#39;);\n     return fire.then(function (result) {\n          console.log(result);\n     });\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"generator\"><a href=\"#generator\" aria-label=\"generator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generator</h3>\n<p>Generator 其實是一個狀態機，內部保存機器的運行狀態。我們透過獲取機器的完成狀態 (done)，我們能夠重複調用機器。我們可以使用 yield 暫停一個函數，並跳出函數。從外面的角度來看，我們可以從上而下去寫代碼，但是代碼會複雜，難以理解。</p>\n<p>雖然它已經寫進 ECMAScript 2015 的正式規範裡面，但是我不太喜歡使用 Generator。我們簡單看一下 Generator 就好了，因為現在是 2017 年，異步操作的有更加好的處理方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen(); // &quot;Generator { }&quot;\ng; //\ng.next(); // {value: 1, done: false}\ng.next(); // {value: 2, done: false}\ng.next(); // {value: 3, done: false}\ng.next() // {value: undefined, done: true}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"asyncawait\"><a href=\"#asyncawait\" aria-label=\"asyncawait permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async/Await</h3>\n<p>對於技術的要求，是無止境的。為了寫出更加優美的代碼，你又可以付出什麼的代價呢？</p>\n<p>如果你沒有試過 Async/Await 的話，那麼你就應該試一下，因為實在是太優雅了。</p>\n<p>這里我就放出一段現在博客在用的代碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">async const getPosts = () =&gt; {\n  await res = axios.get(&#39;https://calpa.me/posts&#39;);\n  return res.data;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我們簡單的讀一下這段代碼：</p>\n<p>一個異步的不變量 <code class=\"language-text\">getPosts</code> 是一個箭頭函數，內部操作為等待 axios 的 GET 請求到地址：<a href=\"https://calpa.me\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://calpa.me</a>，並返回伺服器返回的資料。</p>\n<p>這是一個非常簡單的異步操作吧，但是如果是這樣的呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">async const getUserData = () =&gt; {\n  await posts = axios.get(&#39;https://calpa.me/posts&#39;);\n  await accountInfo = axios.get(&#39;https://calpa.me/about&#39;);\n  /* ... */\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>如果你想要使用 Async / Await 的話，可以使用\n<a href=\"https://www.infoq.com/news/2017/02/node-76-async-await\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Node.js 7.6</a> 或以上的版本。例如使用 nvm 安裝 v8: <code class=\"language-text\">nvm install v8</code>，然後 <code class=\"language-text\">nvm use v8</code>。</p>\n<p>另外，如果你不想更新 Node 版本的話，你可以安裝 <a href=\"https://caolan.github.io/async/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">async 工具庫</a>。</p>\n<h2 id=\"感想\"><a href=\"#%E6%84%9F%E6%83%B3\" aria-label=\"感想 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>感想</h2>\n<p>異步操作已經成為了前端工程師面試常見的問題之一，感覺是對於前端工程師的技術水平需求越來越提高了。雖然這些都是在 MDN 上面寫好的介紹，但是只有自己用過才會知道什麼比較好。</p>\n<p>如果公司的 Node 版本可以支持 Async/Await 的話，那就直接用 Async/Await 就好了。不行的話，那就用 Promise 吧，不然 Generator 的設計對於強迫症患者來說很不順眼。。。</p>\n<h2 id=\"參考資料\"><a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考資料</h2>\n<ol>\n<li><a href=\"https://en.wikipedia.org/wiki/Callback\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Callback (computer programming) - Wikipedia</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Promise - MDN</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Generator</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">async function - JavaScript MDN</a></li>\n</ol>","tableOfContents":"<ul>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#%E5%90%8C%E6%AD%A5%E8%88%87%E7%95%B0%E6%AD%A5%E7%9A%84%E5%88%86%E5%88%A5\">同步與異步的分別</a></li>\n<li>\n<p><a href=\"/2017/09/27/javascript-if-else-in-depth/#%E7%95%B0%E6%AD%A5%E6%93%8D%E4%BD%9C%E8%99%95%E7%90%86%E6%96%B9%E6%B3%95\">異步操作處理方法</a></p>\n<ul>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#callback\">Callback</a></li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#promise\">Promise</a></li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#generator\">Generator</a></li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#asyncawait\">Async/Await</a></li>\n</ul>\n</li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#%E6%84%9F%E6%83%B3\">感想</a></li>\n<li><a href=\"/2017/09/27/javascript-if-else-in-depth/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","excerpt":"…","fields":{"slug":"/2017/09/27/javascript-if-else-in-depth/"},"frontmatter":{"id":"20170927a","title":"異步操作見聞錄","slug":"/2017/09/27/javascript-if-else-in-depth/","date":"2017-09-27T03:48:03.125Z","headerImage":null}},"previous":null,"next":null}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9c369d83-e367-5659-baeb-91b6d76e247c","index":39}}